There is a continuation of the repository 'ForLearningPurpose'. Because this project use Java 11 and Spring 5 it was
necessary to create new repository. Later on, repository "ForLearningPurpose" will be used again.

Tech stack: Java 11, Tomcat 9.0.71, Spring 5.
.jsp is used instead of html just for learning purpose, although it is a legacy

This SumUp file continuous with Section 12.

Section 12 Controllers and Views, Model

@Controller anotacija uždedama virš klasės. @RequestMapping("/") nuoroda į kitą puslapį ir naudojam return, kuris bus naudojamas programos
kaip žymę kurį jsp file atidaryti. Jsp file <form action="".. nurodome /.. kuris nuris nurodo metodą controller'yje. Suteikus input name
, pastarąjį galime panaudoti kaip value ${param.YourElementName) (ex helloworld-form.jsp). MOdel naudojam kaip data transfer ir jsp faile
pateikiam ${SomeName}. NOrint panaudoti model ir gauti bei perduoti informacija, sukuriamas metodas, kur yra 2 arguments
(HttpServletRequest, Model). HttpServletRequest naudojamas gauti info su metodu .getParameter("YourElementName)". Atlikus norimus veiksmus
su gauta informacija, perduoti informacij1 atgal į view naudojam model metodą .addAttribute("SomeName", results(<-your variable name)(žr.13-14 eil).
Žiūrėti pavyzdį HelloWorldController, helloworld.jsp.

Section 13 Request Params and Request Mappings

Kad nereikėtų naudoti HttpServletRequest ir "sutaupyti" laiko bei kodo, galima naudoti @RequestParams anotacij1(Spring'o). Ši anotacija įdedama
metodo argumente -> methodName(@RequestParam("ElementName") VariableType VariableName, Model model).
Jeigu naudojami du controller'iai, kur @RequestMapping(sutrumpinimas RM) yra toks pats, tuomet kažkuriame Controller'yje naudojamas parent @RequestMapping, kuris
nurodomas virš klasės kartu su @Controller anotacija. Tuomet path bus toks /parentRM/chlidRM.

Section 14 Form tags and data binding

Žiūrėti student-confirmation, student-form file. Pastebėjas, kad get/set yra būtina, kuomet naudojamas submit formatas. užsiloadinus formatui iškviečiamas get metodas.Atlikus submit - set metodas.

Section 15 Spring MVC Form Validation - Applying Built-In Validation Rules

Norint apriboti kurį nors field, virš jo galima uždėti anotaciją @NotNull @Size (žr. customer). Vėliau, controller pacakge įterpiame @Valid
anotacija, kuri nusko atlikti validaciją visam objektui . Taip pat įterpiama BindingResult class, kuri laiko informaciją(erro) apie valdicaiją bei binding.
Prieš tai esančios validacijos neapsaugo nuo "space" problemos. Tam naudojamas kitas metodas, kuris pasileidžia pirmas.
@InitBinder anotacija, kuri palaiko validacijos bei indentifikuoja WEbDataBinder metodus. TUomet kaip parametras naudojamas WebDataBidner, kuris susieja puslapio užklausų informaciją su beans.
Sukuriamas StringTrimmerEditor, kuris panaikina trailing bei leading "space". Iškviečias webdatabidner metodas registercustomeditor, kuris pritaiko tam tikrus formato pakitimus tik tam tikram laukui ar formatui
, šiuo atveju( String ir naudojam stringtimmereditor).

Section 16 Spring MVC form validation - validating number ranges and regular expressions.

Norint įvesti apribojimus skaičiams, rašome anotacijas NotNull, Min, Max. Norint
patikrinti ar not null, reikia naudoti Integer, o ne int. Norint apsisaugoti nuo string įvedimo į number,
override error klaidą į aiškesnę. Tam sukuriame messages.properties , kur pradžia typeMismatc(a must).
Toliau spring-mvc-demo-servlet sukuriame bean ir kad skanuotų iš messages.properties.
Norint įvesti Regular Expressions apribojimą - naudojame @Pattern ir regex.{} <- nurodytas skaičius nusako raidžių/skaičių kiekį.(pvz:(regexp="^[a-zA-Z0-9]{5}", message = "only 5 chars/digits"))

Section 17 Spring MVC form validation - creating custom validation rules

Kuriant anotaciją, prieš klasės pavadinimą uždedamas @interface, kuris nurodo, jog čia bus kuriamas custom annotation. Virš klasės nurodome anotaciją @Constraint ir nurodome klasę, kurioje yra mūsų validacijos logika (CourseCodeConstraintValidator).
@Target anotacija naujodama tam, kad nurodyti kur pritaikyti šią anotaciją(skliausteliuose nurodome pvz: ElementType.method/field).
@Retention anotacija naudojama tam, kad nurodyti kuomet turi veikti ši anotacija pvz RetentionPolicy.Runtime. <- nurodo kad veiks programos viso paleidimo metu.
Kad nereikėtų hardcodint, nurodome default value ir message sukurdami metodus. Taip pat, galime nustatyti default groups, kuris sugrupuoja validacijos constraints.
O default payloads metode galime nurodyti papildomą informaciją apie error.
    Sukūrus anotaciją (žr. CourseCode), sukuriam helper class, kur yra validacijos logika. Šiuo atveju - CourseCodeConstraintValidator. Šioje klasėje implement'inam ConstrainValidator,
kur<> nurodome mūsų anotaciją (CourseCode) ir data type, kurią validuosime. Gautųsi <CourseCode, String>.
Tuomet atliekame ovveride initialize ir isValid metodų.
    initialize metode paduodame mūsų anotaciją kaip argumentą. Šis metodas reikalinga inicializuoti anotaciją.
Metodo viduje prilyginame .value() mūsų sukurtam kintamajam,kuris naudojamas patikrinti ar suvestas value praeina validaciją.
    isValid kaip argumentus paduotas String theCode(HTML Form data entered by the user) ir constrainValidatorContext(helper class for additional error messages)
metodo logika: jeigu theCode prasideda su mūsų anotacijos value, tuomet gražinam true. Jeigu result true, tuomet validacija praeita.
    Paleidus programą, pirmiausia nuskaitomas anotacijos message, o po to su juo value.

Section 18 Introduction to hibernate

Hibernate background'e naudoja jdbc. Palengvina komunikaciją tarp paleisto apps'o bei DB. Taip pat, hibernate suteikia object-to-relational mapping (ORM)

Section 19 Setting up hibernate development environment

Connection name = DriverManager.getConnection(url, user, pass) <- naudojamas prisijungti prie mysql. Visgi, bus naudojamas hibernate.cfg.xml
